#!/usr/bin/env python3
#
# Copyright (C) 2023 Hamish Coleman
# SPDX-License-Identifier: GPL-2.0-only
#
# Simple script to query the management interface of a running n3n edge node

import argparse
import collections
import json
import os
import socket
import time
import urllib
import urllib.request


class JsonRPC:
    def __init__(self, url):
        self.debug = False

        if url is None:
            raise ValueError("need url")

        if url.startswith("unix://"):
            self.sessionname = url[7:]
        else:
            self.url = url + "/v1"
        self.timeout = 5
        self.id = 0

    def _data(self, method, params):
        self.id += 1
        data = {
            "jsonrpc": "2.0",
            "id": self.id,
            "method": method,
            "params": params
        }
        json_data = json.dumps(data).encode('utf8')
        if self.debug:
            print("data:", json_data)

        return json_data

    def _request_obj(self, method, params):
        data = self._data(method, params)

        req = urllib.request.Request(
            method="POST",
            url=self.url,
            headers={
                "Content-Type": "application/json",
            },
            data=data,
        )
        return req

    def get(self, method, params=None):
        if hasattr(self, "sessionname"):
            sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
            path = f"/run/n3n/{self.sessionname}/mgmt"
            sock.connect(path)
            data = b"POST /v1 \r\n\r\n" + self._data(method, params)
            sock.sendall(data)

            reply = sock.recv(16384)
            _, body = reply.split(b"\r\n\r\n")

        else:
            req = self._request_obj(method, params)

            r = urllib.request.urlopen(req, timeout=self.timeout)
            if r.status != 200:
                raise ValueError(f"urllib request got {r.status} {r.reason}")

            body = r.read()

        if self.debug:
            print("reply:", body)
        r = json.loads(body)

        if "result" not in r:
            raise ValueError("jsonrpc error")

        assert (r['id'] == str(self.id))

        return r['result']


def str_table(rows, columns, orderby):
    """Given an array of dicts, do a simple table print"""
    result = list()
    widths = collections.defaultdict(lambda: 0)

    if len(rows) == 0:
        # No data to show, be sure not to truncate the column headings
        for col in columns:
            widths[col] = len(col)
    else:
        for row in rows:
            for col in columns:
                if col in row:
                    widths[col] = max(widths[col], len(str(row[col])))

    for col in columns:
        if widths[col] == 0:
            widths[col] = 1
        result += "{:{}.{}} ".format(col, widths[col], widths[col])
    result += "\n"

    if orderby is not None:
        rows = sorted(rows, key=lambda row: row.get(orderby, 0))

    for row in rows:
        for col in columns:
            if col in row:
                data = row[col]
            else:
                data = ''
            result += "{:{}} ".format(data, widths[col])
        result += "\n"

    return ''.join(result)


def num2timestr(seconds):
    """Convert a number of seconds into a human time"""

    if seconds == 0:
        return "now"

    days, seconds = divmod(seconds, (60*60*24))
    hours, seconds = divmod(seconds, (60*60))
    minutes, seconds = divmod(seconds, 60)

    r = []
    if days:
        r += [f"{days}d"]
    if hours:
        r += [f"{hours}h"]
    if minutes:
        r += [f"{minutes}m"]
    if seconds:
        r += [f"{seconds}s"]
    return "".join(r)


def subcmd_show_supernodes(rpc, args):
    rows = rpc.get('get_supernodes')
    columns = [
        'version',
        'current',
        'macaddr',
        'sockaddr',
        'uptime',
        'last_seen',
    ]

    now = int(time.time())
    for row in rows:
        row["last_seen"] = num2timestr(now - row["last_seen"])

    return str_table(rows, columns, args.orderby)


def subcmd_show_edges(rpc, args):
    rows = rpc.get('get_edges')
    columns = [
        'mode',
        'ip4addr',
        'macaddr',
        'sockaddr',
        'desc',
        'last_seen',
    ]

    now = int(time.time())
    for row in rows:
        row["last_seen"] = num2timestr(now - row["last_seen"])

    return str_table(rows, columns, args.orderby)


def subcmd_show_help(rpc, args):
    result = 'Commands with pretty-printed output:\n\n'
    for name, cmd in subcmds.items():
        result += "{:12} {}\n".format(name, cmd['help'])

    result += "\n"
    result += "Possble remote commands:\n"
    result += "(those without a pretty-printer will pass-through)\n\n"

    try:
        rows = rpc.get('help')
        for row in rows:
            result += "{:15} {}\n".format(row['method'], row['desc'])
    except urllib.error.HTTPError:
        result += "Error requesting help data"

    return result


subcmds = {
    'help': {
        'func': subcmd_show_help,
        'help': 'Show available commands',
    },
    'supernodes': {
        'func': subcmd_show_supernodes,
        'help': 'Show the list of supernodes',
    },
    'edges': {
        'func': subcmd_show_edges,
        'help': 'Show the list of edges/peers',
    },
}


def subcmd_default(rpc, args):
    """Just pass command through to edge"""
    method = args.cmd
    params = args.args
    rows = rpc.get(method, params)
    return json.dumps(rows, sort_keys=True, indent=4)


def main():
    ap = argparse.ArgumentParser(
            description='Query the running local n3n edge')
    ap.add_argument('-s', '--sessionname', action='store',
                    help='Which session to use')
    ap.add_argument('-u', '--mgmturl', action='store',
                    help='Management API URL')
    ap.add_argument('-k', '--key', action='store',
                    help='Password for mgmt commands')
    ap.add_argument('-d', '--debug', action='store_true',
                    help='Also show raw internal data')
    ap.add_argument('--raw', action='store_true',
                    help='Force cmd to avoid any pretty printing')
    ap.add_argument('--orderby', action='store',
                    help='Hint to a pretty printer on how to sort')

    ap.add_argument('cmd', action='store',
                    help='Command to run (try "help" for list)')
    ap.add_argument('args', action='store', nargs="*",
                    help='Optional args for the command')

    args = ap.parse_args()

    if args.sessionname is not None:
        args.mgmturl = "unix://" + args.sessionname

    if args.mgmturl is None:
        # try to guess the sessionname
        try:
            sessions = os.listdir("/run/n3n")
        except FileNotFoundError:
            sessions = []

        if len(sessions) == 0:
            print("Error: no sessions found, please specify --url")
            exit(1)
        elif len(sessions) == 1:
            # There is only one session, so choose that one
            args.mgmturl = "unix://" + sessions[0]
        else:
            print("Error: found multiple sessions:")
            print()
            print("\t", " ".join(sessions))
            print()
            print("please use --sessionname to choose one")
            exit(1)

    if args.raw or (args.cmd not in subcmds):
        func = subcmd_default
    else:
        func = subcmds[args.cmd]['func']

    rpc = JsonRPC(args.mgmturl)
    rpc.debug = args.debug
    rpc.key = args.key

    try:
        result = func(rpc, args)
    except socket.timeout as e:
        print(e)
        exit(1)

    print(result)


if __name__ == '__main__':
    main()

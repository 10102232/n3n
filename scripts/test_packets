#!/usr/bin/env python3
"""Send and recieve test packets"""
#
# Copyright (C) 2024 Hamish Coleman
# SPDX-License-Identifier: GPL-2.0-only

import argparse
import pprint
import socket
import struct


def hexdump(display_addr, data):
    size = len(data)

    row = 0
    while size > 0:
        print(f"{display_addr:03x}: ", end="")

        for i in range(16):
            if i < size:
                print(f"{data[row+i]:02x}", end="")
            else:
                print("  ", end="")

            if i == 7:
                print(" ", end="")
            print(" ", end="")

        print("  |", end="")

        for i in range(16):
            if i < size:
                ch = data[row+i]
                if ch >= 0x20 and ch <= 0x7e:
                    print(chr(ch), end="")
                else:
                    print(" ", end="")

        print("|")

        size -= 16
        display_addr += 16
        row += 16


class PacketBase():
    names = [
        None,
        "REGISTER",             # 1
        "DEREGISTER",           # this packet never used in original code
        "PACKET",
        "REGISTER_ACK",
        "REGISTER_SUPER",       # 5
        "UNREGISTER_SUPER",
        "REGISTER_SUPER_ACK",
        "REGISTER_SUPER_NAK",
        "FEDERATION",
        "PEER_INFO",            # 10
        "QUERY_PEER",
        "RE_REGISTER_SUPER",
    ]

    @classmethod
    def id2type(cls, id):
        return cls.names[id]

    @classmethod
    def type2id(cls, name):
        return cls.names.index(name)

    defaults = {
        "data": {
            "proto_version": 3,
            "ttl": 2,
            "flags": 0,
            "community": b"test",
            "cookie": 0x1000,
            "srcMac": b"\x00\x00\x00\x00\x00\x01",
            "dstMac": b"\x00\x00\x00\x00\x00\x02",
            "edgeMac": b"\x00\x00\x00\x00\x00\x03",
            "targetMac": b"\x00\x00\x00\x00\x00\x04",
            "ipv4": b"\x00\x00\x00\x00",
            "masklen": 0,
            "desc": b"packetgenerator",
            "auth_scheme": 0,   # n2n_auth_none
            "auth_token_size": 0,
            "auth_token": b"",
            "key_time": 600,
            "aflags": 0,
            "compression": 1,   # COMPRESSION_ID_NONE
            "transform": 1,     # TRANSFORM_ID_NULL
            "packet": b"\x02\x00\x00\x00\x00\x11"
                b"\x02\x00\x00\x00\x00\x22"
                b"\x0f\x0f"
                b"\x55\xaa",
        },
        "format": "!BBH20s",
        "fields": [
            "proto_version",
            "ttl",
            "type_flags",
            "community",
        ],
    }

    @classmethod
    def set_default(cls, key, val):
        cls.defaults["data"][key] = val

    @classmethod
    def get_default(cls, key):
        return cls.defaults["data"][key]

    types = {
        "test_REGISTER": {
            "data": {
                "type": 1,
            },
            "format": "I6s6s4sB16s",
            "fields": [
                "cookie",
                "srcMac",
                "edgeMac",
                # TODO? Optional sock
                "ipv4",
                "masklen",
                "desc",
            ],
        },
        # 1:
        #   TODO
        #   - the test_REGISTER scenario causes the packet to be forwarded
        #   - the forwarded version has the optional sock added
        #   - so we want a way to share the frame definition, but support
        #     the optional sock :-(
        "test_PACKET": {
            "data": {
                "type": 3,
            },
            "format": "6s6sBB64s",
            "fields": [
                "srcMac",
                "edgeMac",
                # TODO? Optional sock
                "compression",
                "transform",
                "packet",
            ],
        },
        "test_REGISTER_SUPER": {
            "data": {
                "type": 5,
            },
            "format": "I6s4sB16sHHL",
            "fields": [
                "cookie",
                "edgeMac",
                # TODO? Optional sock
                "ipv4",
                "masklen",
                "desc",
                "auth_scheme",
                "auth_token_size",
                # "auth_token" if token_size
                "key_time",
            ],
        },
        "test_UNREGISTER_SUPER": {
            "data": {
                "type": 6,
            },
            "format": "HH6s",
            "fields": [
                "auth_scheme",
                "auth_token_size",
                # "auth_token" if token_size
                "edgeMac",
            ],
        },
        7: {
            "format": "I6s4sBHHH4sHHB",
            "fields": [
                "cookie",
                "srcMac",
                "ipv4",
                "masklen",
                "lifetime",
                "sock_flag",
                "sock_port",
                "sock_v4",      # FIXME - variable size, based on sock_flag
                "auth_scheme",
                "auth_token_size",
                # "auth_token",   # FIXME - variable size, based on token_size
                "num_sn",
                # TODO: SN buf
            ],
        },
        10: {
            "format": "H6s6sHH4sLL20s",
            "fields": [
                "aflags",
                "srcMac",
                "mac",
                "sock_flag",
                "sock_port",
                "sock_v4",      # FIXME - variable size, based on sock_flag
                # TODO: optional preferred_sock
                "load",
                "uptime",
                "version",
            ],
            "unstable_fields": {
                "load": 0xffffffff,
                "uptime": 0xffffffff,
                "version": b"_stabilised_",
            },
        },
        "test_QUERY_PEER": {
            "data": {
                "type": 11,
            },
            "format": "6s6sH",
            "fields": [
                "srcMac",
                "edgeMac",
                "aflags",
            ],
        },
        "test_QUERY_PEER_ping": {
            "data": {
                "type": 11,
                "targetMac": b"\x00\x00\x00\x00\x00\x00",
            },
            "format": "6s6sH",
            "fields": [
                "srcMac",
                "targetMac",
                "aflags",
            ],
        }
    }

    def __init__(self, scenario):
        # Set the default values for the common fields
        self.data = self.defaults["data"].copy()
        self.format = self.defaults["format"]
        self.fields = self.defaults["fields"].copy()
        self.buffer = None

        self.unstable_fields = {}
        if scenario in self.types:
            if "data" in self.types[scenario]:
                self.data.update(self.types[scenario]["data"])
            self.format += self.types[scenario]["format"]
            self.fields += self.types[scenario]["fields"]
            if "unstable_fields" in self.types[scenario]:
                self.unstable_fields = self.types[scenario]["unstable_fields"]

    def encode(self):
        if "type" not in self.data:
            raise ValueError("Unknown packet type")

        # special case for this one field
        self.data["type_flags"] = self.data["type"] & 0x1f
        self.data["type_flags"] |= self.data["flags"] & 0xffe0

        fielddata = [self.data[f] for f in self.fields]
        self.buffer = struct.pack(self.format, *fielddata)
        return self.buffer

    def decode(self, buffer):
        # first, get the type
        data = struct.unpack("!BBH", buffer[:4])
        pkt_type = data[2] & 0x1f

        # now, turn ourselves into that type
        self.__init__(pkt_type)
        self.buffer = buffer

        formatstr = self.format
        calcsize = struct.calcsize(formatstr)
        if len(buffer) > calcsize:
            # dont abort on to many bytes, simply ignore them all
            formatstr += f"{len(buffer) - calcsize}x"
        if len(buffer) < calcsize:
            print(f"buffer: {len(buffer)}")
            print(f"calcsize: {calcsize}")
            print(f"format: {formatstr}")
            raise ValueError("buf too small")

        # finally, properly decode
        self.data = { }
        try:
            self.data["_name"] = self.id2type(pkt_type)
        except IndexError:
            # probably header encrypted
            return self.data

        data = struct.unpack(formatstr, buffer)

        for i in range(len(data)):
            key = self.fields[i]
            val = data[i]
            self.data[key] = val

        # special case for this one field
        self.data["type"] = self.data["type_flags"] & 0x1f
        self.data["flags"] = self.data["type_flags"] & 0xffe0

        return self.data

    def stable_values(self):
        """Remove fields that will constantly change - allowing testing"""

        changed = False
        for field, val in self.unstable_fields.items():
            self.data[field] = val
            changed = True

        if changed and self.buffer is not None:
            self.encode()


# to supernode:
# - PACKET -> forwarded to another node
# - REGISTER -> forwarded
# - REGISTER_SUPER -> REGISTER_SUPER_NAK or REGISTER_SUPER_ACK and/or forwarded
# - UNREGISTER_SUPER -> deletes peer, no reply
# - QUERY_PEER -> PEER_INFO
# - PEER_INFO -> forwarded

# to edge:
# - PACKET -> processed to tun
# - REGISTER -> if !from_supernode, REGISTER_ACK
# - PEER_INFO -> REGISTER
# - RE_REGISTER_SUPER -> REGISTER_SUPER , multicast REGISTER


def main():
    ap = argparse.ArgumentParser(description=__doc__)
    ap.add_argument(
        "-s",
        "--server",
        help="host and port of server to contact",
        default="localhost:1968"
    )
    ap.add_argument(
        "--bind",
        help="bind local socket to port",
        type=int,
        default=False
    )
    ap.add_argument(
        "-c",
        "--community",
        help="The n3n community name",
        default="test"
    )
    ap.add_argument(
        "-t",
        "--timeout",
        type=int,
        help="how long to wait for replies",
        default=10
    )
    ap.add_argument(
        "--raw",
        help="Dont stablise the results - show the real data",
        default=False
    )
    ap.add_argument("scenario", help="What packet to send")

    args = ap.parse_args()

    host, sep, port = args.server.partition(":")
    port = int(port)

    community = args.community.encode("utf8")
    PacketBase.set_default("community", community)

    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    sock.settimeout(args.timeout)
    if args.bind:
        sock.bind(('', args.bind))

    if args.scenario != "listen":
        send_pkt = PacketBase(args.scenario)
        buf = send_pkt.encode()
        print("test:")
        hexdump(0, buf)

        sock.sendto(buf, (host, port))

    if args.timeout == 0:
        return

    data = sock.recv(1600)

    recv_pkt = PacketBase(None)
    recv_pkt.decode(data)

    if not args.raw:
        recv_pkt.stable_values()

    print("recv:")
    hexdump(0, recv_pkt.buffer)
    pprint.pp(recv_pkt.data)


if __name__ == '__main__':
    main()
